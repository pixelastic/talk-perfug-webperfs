<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Les webperfs pour les nuls</title>
  <meta name="description" content="Présentation PerfUG Août 2014">
  <meta name="author" content="Timothée Carry">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/octo.css" id="theme">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="lib/css/zenburn.css">
  <script>
    if (window.location.search.match(/print-pdf/gi)) {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'css/print/pdf.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    }
  </script>
  <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <h1>Les webperfs<br />pour les nuls</h1>
      </section>

      <section>
        <h2>Timothée Carry</h2>
        <ul>
          <li>Consultant Octo Technology</li>
          <li>Spécialiste en Web Front</li>
          <li><a href="https://twitter.com/pixelastic/">@pixelastic</a> à l'extérieur</li>
        </ul>
      </section>

      <section>
        <section data-background="/img/why-background.jpg">
          <h1>Pourquoi ?</h1>
        </section>
        <section>
          <h3>Impact sur la marque</h3>
          <ul>
            <li>
              <p>Utilisateurs de moins en moins patients</p>
              <ul>
                <li>Site lent au bout de 4s en 2008, 3s en 2014</li>
                <li>Nouvelle génération habituée à l'instantané</li>
                <li>Explosion du nombre de terminaux mobiles</li>
              </ul>
            </li>
            <li>
              <p>Relation à l'image de marque</p>
              <ul>
                <li>Avantage concurrentiel si rapide</li>
                <li>Frustration reportée sur la marque si lent</li>
              </ul>
            </li>
          </ul>
          <blockquote>Amazon perd 1% de ventes pour chaque tranche de 100ms de chargement</blockquote>
        </section>
      </section>

      <section>
        <section data-background="/img/server-background.jpg">
          <h1>Serveur</h1>
        </section>

        <!-- <section> -->
        <!--   <h3>Tirer profit de la requête HTTP</h3> -->
        <!--   <ul> -->
        <!--     <li>Limiter les cookies</li> -->
        <!--     <li>Concaténer les éléments</li> -->
        <!--     <li>Compresser les assets</li> -->
        <!--     <li>Mettre en cache</li> -->
        <!--   </ul> -->
        <!-- </section> -->

        <section>
          <h3>Régime sans cookies</h3>
          <ul>
            <li>Envoyé sur chaque requête</li>
            <li>Inutile pour les assets statiques</li>
          </ul>
          <ul>
            <li>Utiliser des sous-domaines cookieless</li>
            <li>Passer le tracking sur son propre sous-domaine</li>
          </ul>
        </section>

        <section>
          <h3>Un pour tous et tous pour un</h3>
          <!-- <img src="./img/server-client-server.png" alt="Il m'a regardé, je l'ai regardé" width="500"/> -->
          <ul>
            <li>Concatener les assets de même type en un seul fichier</li>
            <li>1 (ou 2) fichiers Javascript et CSS</li>
            <!-- <li>Amélioration du Gzip</li> -->
          </ul>
          <!--// Todo: Image d'une connection à X fichiers, ou un seul.-->
          <blockquote>Comment réduire la taille des requêtes ? Faites moins de requêtes.</blockquote>
        </section>

        <section>
          <h3>Gzip all the things!</h3>
          <ul>
            <li>
              <p>Gain de 66% en moyenne</p>
              <ul>
                <li>Gains plus importants sur des gros fichiers</li>
                <li>Compression favorisée par les conventions (attributs HTML, propriétés CSS)</li>
              </ul>
            </li>
            <li>
              <p>Large spectre</p>
              <ul>
                <li>HTML / CSS / Javascript</li>
                <li>XML / JSON</li>
                <li>SVG / WOFF</li>
              </ul>
            </li>
          </ul>
          <div class="warning fragment">
            <p>Toujours permettre une version sans Gzip (proxies, vieux navigateurs)</p>
          </div>
          <aside class="notes">
            <p>Presque tous les browsers supportent gzip, mais les proxies peuvent modifier les Request/Response header et donc
              empecher un asset gzip d'etre considéré comme tel.</p>
          </aside>
        </section>

        <section>
          <h1>Images</h1>
          <ul>
            <li>Souvent le plus lourd sur une page, et de loin.</li>
            <li>Utiliser le bon format pour le bon usage.</li>
          </ul>
        </section>

        <section>
          <h1>JPG</h1>
          <ul>
            <li>Pour les photos.</li>
            <li>Compression lossy ~ 80% à l'oeil nu (convert, jpegoptim).</li>
            <li>Compression lossless suppression metadatas (exiftool).</li>
            <li>Problématiques responsive/retina (hors scope).</li>
          </ul>
          <aside class="notes">
            - Les graphistes ont une meilleure perception de la compression que les développeurs.
            - Certaines metadatas ne doivent pas disparaitre (author, copyright, etc).
          </aside>
        </section>

        <section>
          <h1>GIF</h1>
          <ul>
            <li>Palette de 256 couleurs.</li>
            <li>Un seul canal de transparence.</li>
            <li>Se compresse peu.</li>
            <li>...</li>
            <li>Images animées<br /><img src="./img/server-gif.gif" alt="Gif animé" width="250"/> </li>
          </ul>
          <aside class="notes">
            Si vous avez des gifs animés sur votre site, vous avez un problème plus grave qu'un soucis de performances.
          </aside>
        </section>

        <section>
          <h1>PNG</h1>
          <ul>
            <li>Filesize plus léger que GIF.</li>
            <li>Plusieurs canaux de transparence.</li>
            <li>256 couleurs pour PNG-8, infinité pour PNG-24.</li>
            <li>tinypng, pngquant, punypng, etc.</li>
          </ul>
          <div>
            <h3>Attention</h3>
            <ul>
              <li>Photoshop gère mal PNG-8.</li>
              <li>Pas supporté par IE8 (attention aux hacks).</li>
            </ul>
          </div>
        </section>

        <section>
          <h1>Sprites</h1>
          <div class="sprite-container">
            <img src="./img/server-sprite-fun.jpg" alt="Sprite fun" class="fragment sprite-fun" />
            <img src="./img/server-sprites.png" alt="Google sprite" class="fragment sprite-example"/>
          </div>
          <ul>
            <li>Plusieurs images en une.</li>
            <li>Gain sur le nombre de requetes et sur la compression.</li>
            <li>On joue ensuite sur background-position en CSS.</li>
          </ul>
          <div>
            <h3>Attention</h3>
            <ul>
              <li>Nécessite des éléments de taille fixe.</li>
            </ul>
          </div>
          <aside class="notes">
            Peut être parfois remplacé par CSS (gradients, border-radius).
            Peut être parfois remplacé par des Icon Fonts.
            Source des images : http://www.loriskumo.com/des-sprites-css-pour-votre-site/
          </aside>
        </section>


        <section>
          <h1>Cache</h1>
          Une fois téléchargé, inutile de le télécharger à nouveau.
          HTTP propose des mécanismes puissants pour gérer le cache, à deux niveaux.
          Au niveau du browser (ne lance la requete que si la date est expirée), ou au
          niveau du server (indique au serveur la dernière date, le serveur réponds avec
          une nouvelle version ou rien si la version actuelle est ok).
          Plusieurs mécanismes, je présente ceux que je préfère.
          Invalidation du cache, l'une des choses les plus difficile. Asset caché potentiellement par des proxies, firewalls,
          Plus simple de changer l'url. Timestamp de dernière génération dans l'url, md5 dans le nom, etc.
        </section>


        <section>
          Inutile de charger gros framework si utilise juste quelques parties. Tout ce code est chargé par le client.
          Plutot faire un build sur mesure (jQuery, Bootstrap), ou utiliser de smicro-librairies
        </section>
          
          
        <section>
          Inutile de charger des fonts complètes. Ne sélectionner que les caractères nécessaires. 
          On peut virer les versions bols et italiques si pas nécessaires non plus. 
          Si assez petit, toujours possible de les ajouter en base64 dans le CSS
        </section>

        <section>
          Limiter le nombre de requetes. 
          Une ou deux pour CSS et JS (une si petit, sinon deux en primordial et secondaire)
        </section>

      </section>

      <section>
        <section data-background="/img/client-background.jpg">
          <h1>Client</h1>
        </section>

        <section>
          Expliquer le startRender, startExecution, etc
        </section>

        <section>
          HTML
          Pas grand chose à dire ici.
          Limiter le nombre de balises, aide aussi à la maintenabilité
          Code guide mdo
        </section>

        <section>
          Parsing du CSS
          Depuis la droite jusque la gauche, sélecteurs plus couteux que d'autres.
          Contre-intuitif, de dire que si super précis à gauche, alors selecteur optimisé. Inverse.
          Eviter le selecteur universel *, et les regexp dans les selecteurs d'attributs.
        </section>

        <section>
          Start Render Explication reflow/repaint.
          D'où, mettre CSS en haut pour lui économiser les reflows.
          Micro optim de mettre le contenu important déjà chargé en inline cf. 
          Guardian
        </section>
          
          
        <section>
          First execution
          Téléchragment de JS bloquant.
          A donc mettre en bas de page pour limiter, ou utiliser du async/defer (vérifier le fonctionnement). 
          Javasript bloquant car document.write peut changer le dom.
          Attention aux scripts de publicité (js-manners) 
        </section>
          
        <section>
          Asynchrone. 
          Prioriser ce qui doit se charger. 
          Tout ça n'est qu'au premier chargement, avant même que le user n'ai pu faire quoique ce soit. 
          Important donc de prioriser ce qui doit se charger en premier. 
          Boutons de sharing arrivent après contenu, idem pour la publicité et le tracking des visites. 
          Pas toujours facile à négocier avec le service marketing/etc. 
        </section>
          
          
        <section>
          Animation/transitions
          Grande majorité des effets d'animations sont faisable en simple CSS, sans passer par du js. 
          Tant que le JS s'execute, rien d'autre ne se passe. 
          Apparté sur la manière dont les boucles d'animations fonctionnent en JS 
          Une méthode qui se charge aussi souvent que possible (setTimeout) et qui calcule la 
          durée depuis la dernière fois et sait où elle se trouve dans l'animation, donc modifie les propriétés en fonctions. 
          Si modifie taille => reflow, sinon repaint. Comme repasse la main au browser, plein de repaint. 
          Plus performant de faire ces animations en CSS directement, car pluggué tout de suite sur GPU 
        </section>

        <section>
          CPU/GPU
          + Revoir la présentation de Paul Rouget à la TakeOff sur qui fait quoi, et comment en profiter?
        </section>

        <section>
          Usual Suspect #1
          Evenements qui fire trop régulièrement.
          Sur mousemove, scroll, etc.
        </section>

        <section>
          Usual Suspect #2
          Fuite mémoire avec des éléments supprimés du DOM qui ont toujours un
          event bindé, et donc pas supprimé
          Généralement moins couteux de mettre un seul événement sur un événement parent
          et profiter du bubbling.
        </section>

        <section>
          Usual suspect #3
          Ajouter plein d'éléments dans le DOM à le suite, force des reflow
          Les faire en batch
          Exemple d'une boucle qui ajoute plein d'éléments
        </section>


      </section>

      <section>
        <section data-background="/img/human-background.jpg">
          <h1>Humain</h1>
        </section>

        <section>
          http://calendar.perfplanet.com/2012/why-bother-with-performance-metrics-when-you-can-cheat/
          Mozilla make the throbber faster
          Tricher sur le easing, slow, puis de plus en plus fast
          Avoir des bandes qui bougent dans le sens inverse, augmente perception de vitesse
        </section>

        <section>
          Les utilsiateurs ne se disent pas "oh, ce site est lent, c'est dommage", mais "cette marque est pas très performante".
          Même site, même ergo, testée en ajoutant simplement un délai de 500ms est passé de "simple, facile à utiliser", à "lent, basique, dur à utiliser".
          http://calendar.perfplanet.com/2013/slow-pages-damage-perception/
        </section>


        <section>
          Finalement on optimise le chargement de nso pages pour que l'utilisateur final
          voit un site qui se charge vite. En plus d'influer sur la technique, on peut aussi influer sur
          le cerveau
        </section>

        <section>
          Placeholder
          Il est mieux de commencer à afficher quelque chose (même un bandeau de couleur)
          pour le header, ou des éléments non-utilisables plutot qu'un spinner qui tourne indéfiniment
        </section>

        <section>
          Spinner infini
          Rien de plus frustrant qu'une barre de progression qui n'évolue pas, ou qui continue plusieurs fois
          Eviter les spinner qui donnent une sensation de complétude si on ne peut pas la garantir
        </section>

        <section>
          L'oeil humain ne percoit rien en dessous de 100ms. Si une action prends moins de 300ms, elle
          est percu comme instanée. Inutile donc de mettre un spinner pour moins de 300ms.
          Au contraire, ca va lui donner la sensation que les choses sont lentes.
        </section>

        <section>
          Il peut arriver que les choses plantent, ou prennent plus de temps que prévu.
          Dans ce cas, il ne faut pas que l'utilisateur soit obligé de quitter la page.
          Il doit toujours pouvoir naviguer et aller autre part.
          Pas de backdrop qui prends tout et qui empeche de naviguer
        </section>

        <section>
          Enfin, comme disent les Animaniacs "If at first you don't suceed, blame it on your parents".
          Si c'est lent, essayer de faire en sorte que ce ne soit pas vous qu'on accuse.
          Facebook a fait le test sur son appli mobile, s'ils utilisent le spinner facebook, on pense que leur 
          appli est lente, s'ils utilisent le spinner iOs, on pense que l'iPhone est lent.
        </section>

      </section>

      <section data-background="/img/questions-background.jpg">
        <h1>Questions ?</h1>
      </section>


      <section>
        <section>
          <h1>Annexes</h1>
        </section>
        <section>
          <h2>Des ressources existent depuis longtemps</h2>
          <ul>
            <li><a href="http://www.dailymotion.com/video/x7op91_eric-daspet-nicole-sullivan-perform_tech">ParisWeb 2008</a></li>
            <li><a href="http://www.slideshare.net/jpvincent/performances-web-quoi-de-neuf">KiwiParty 2014</a></li>
          </ul>
        </section>
        <section>
          <h3>Des outils matures</h3>
          <ul>
            <li><a href="http://www.webpagetest.org/">WebPageTest</a></li>
            <li><a href="http://newrelic.com/">NewRelic</a></li>
            <li><a href="http://appurify.com/">Appurify</a></li>
          </ul>
        </section>

        <section>
          <h1>Serveur</h1>
        </section>

        <section>
          <h3>DNS, le goulet d'étranglement</h3>
            <ul>
              <li>Passage obligatoire de toute requête</li>
              <li>Zone grise entre le client et le serveur</li>
              <li>Limite de connections simultanées coté client</li>
              <li>Peu de solutions (limiter le nombre de domaines)</li>
            </ul>
        </section>

        <section>
          <h3>Le CDN est la dernière étape, pas la première</h3>
          <ul>
            <li>Souvent utilisé comme solution de facilité</li>
            <li>Gains plus importants sur les autres points</li>
            <li>À utiliser
          </ul>
        </section>

        <section>
          <h3>Adaptez à votre cas de figure</h3>
          <ul>
            <li><a href="http://www.jonathanklein.net/2014/02/revisiting-cookieless-domain.html">Etsy</a> charge ses assets statiques depuis le même domaine que le site principal</li>
          </ul>
      </section>



    </div>

  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.min.js"></script>

  <script>
    // Full list of configuration options available here:
     // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: false,
      progress: true,
      history: true,
      center: true,

      transition: 'linear',

      // Optional libraries used to extend on reveal.js
      dependencies: [{
        src: 'lib/js/classList.js',
        condition: function() {
          return !document.body.classList;
        }
      }, {
        src: 'plugin/highlight/highlight.js',
        async: true,
        callback: function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src: 'plugin/notes/notes.js',
        async: true,
        condition: function() {
          return !!document.body.classList;
        }
      }]
    });
  </script>

</body>

</html>
