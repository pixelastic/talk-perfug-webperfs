<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Les webperfs pour les nuls</title>
  <meta name="description" content="Présentation PerfUG Août 2014">
  <meta name="author" content="Timothée Carry">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">
  <link rel="stylesheet" href="lib/css/zenburn.css">
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if (window.location.search.match(/print-pdf/gi)) {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'css/print/pdf.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    }
  </script>
  <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <h1>Les webperfs pour les nuls</h1>
      </section>

      <section>
        <h2>Qui suis-je ?</h2>
        <h3>Timothée Carry</h3>
        <ul>
          <li>Consultant @ Octo Technology</li>
          <li>Spécialisé en Web Front</li>
          <li><a href="https://twitter.com/pixelastic/">@pixelastic</a> à l'extérieur</li>
        </ul>
      </section>

      <section>
        <section>
          <h1>Pourquoi ?</h1>
        </section>
        <section>
          <blockquote>Amazon perds 1% de ventes pour chaque tranche de 100ms de chargement.</blockquote>
        </section>
        <section>
          <ul>
            <li>Temps d'attente moyen en baisse, habitude de l'instantané</li>
            <li class="fragment">Avantage concurrentiel</li>
            <li class="fragment">Impacte directement la marque</li>
          </ul>
          <aside class="notes">
            - Site considéré lent au bout de 4s en 2008, 3s aujourd'hui.
            - Si le site du concurrent est plus rapide, cela lui donne un avantage sur vous
            - La performance du site est directement affectée à la marque dans l'esprit des utilisateurs
          </aside>
        </section>
        <section>
          <h2>Pas nouveau</h2>
          <a href="http://www.dailymotion.com/video/x7op91_eric-daspet-nicole-sullivan-perform_tech" class="fragment">ParisWeb 2008</a>
        </section>
      </section>

      <section>
        <section>
          <h1>Anatomie d'une requête</h1>
        </section>
        <section>
          Exemple sur un site existant. Requete initiale, HTML recu, assets chargés, startRender, startExecution.
          WebPageTest
          Parler des solutions en SaaS pour simuler des connections mobiles.
        </section>
      </section>

      <section>
        <section>
          <h1>Serveur</h1>
        </section>
        <section>
          Quoi commencer à optimiser ? Inutile de perdre trop de temps à optimiser coté back.
          Globalement, c'est pas là le bottleneck. Si vraiment long, on peut, mais il y a beaucoup plus à gagner à coté.
        </section>

        <section>
          Gagner sur les DNS
          Pas grand chose à faire, si ce n'est éviter de charger des assets depuis des domaines différents

            Connection DNS, etc, on peut pas y faire grand chose. Limité par la vitesse de la lumière, on peut grapiller, mais pas beaucoup.
          Browser ont une maximum de connections simultanées, et simultanée par host (sous-domaines considérés comme différents hosts).
        </section>


        <section>
          Gagner sur le temps de connection après DNS
          Mettre un CDN pour être au plus proche des utilisateurs.
          Souvent employé comme solution miracle, alors qu'il y a beaucoup plus à gagner en
          optimisant le reste
        </section>

        <section>
          Réduire la taille des assets à télécharger
          Ah, ça devient intéressant. On gzip tout ce qui est texte.
          (Vérifier qui ne supporte pas gzip). CSS, JS, Woff, xml, json. On divise
          par trois en moyenne.
          Ne pas compresser en gzip les images.
        Micro-optim :
        Toujours mettre attributs HTML, CSS, etc dans le même ordre pour améliorer la compression gzip.
        grunt to the rescue
        </section>

        <section>
          Images
          Souvent le plus lourd sur une page, et de loin. 
          Utiliser les méthodes de compressions des images. Gif ne se compresse pas, ou très peu. 
          Jpg bien pour les photos. Compresse bien. Comrpession lossy, 80% reste globalement invisible à l'oeil nu.
          Lossless, on supprimes les metadata (exiftool). Certains prennent de la place pour rien : thumbnail, type de flash, exposure, etc.
          Attention toutefois, certaines doivent rester : auteur, date, lieu, copyright, etc.
          png > gif : plusieurs canaux de transparence. Gif peut être plus léger sur de tout petits fichiers, mais
          comme on le verra plus tard, il vaut mieux cumuler les fichiers en sprite
          png n'est pas animé mais... wtf gif animé ? "Si vous avez des gifs animés sur votre site, vous avez un problème plus grave"
        </section>

        <section>
          Sprites
          Pour les icones, on peut utiliser des sprites, pour cumuler plusieurs éléments en une seule image et jouer avec
          le background position. Peut être remplacé par CSS ou icon fonts.
        </section>

        <section>
          Concaténation
          "Il m'a regardé, je l'ai regardé, il m'a regardé"
          Indispensable. L'un des plus gros gain. Ne charger qu'un seul fichier CSS ou JS plutot que plusieurs fichiers.
          On gagne énormément en faisant ainsi. Le gzip fonctionne encore mieux.o
        </section>

        <section>
          Cache
          Une fois téléchargé, inutile de le télécharger à nouveau.
          HTTP propose des mécanismes puissants pour gérer le cache, à deux niveaux.
          Au niveau du browser (ne lance la requete que si la date est expirée), ou au
          niveau du server (indique au serveur la dernière date, le serveur réponds avec
          une nouvelle version ou rien si la version actuelle est ok).
          Plusieurs mécanismes, je présente ceux que je préfère.
          Invalidation du cache, l'une des choses les plus difficile. Asset caché potentiellement par des proxies, firewalls,
          Plus simple de changer l'url. Timestamp de dernière génération dans l'url, md5 dans le nom, etc.
        </section>


        <section>
          Inutile de charger gros framework si utilise juste quelques parties. Tout ce code est chargé par le client.
          Plutot faire un build sur mesure (jQuery, Bootstrap), ou utiliser de smicro-librairies
        </section>
          
          
        <section>
          Inutile de charger des fonts complètes. Ne sélectionner que les caractères nécessaires. 
          On peut virer les versions bols et italiques si pas nécessaires non plus. 
          Si assez petit, toujours possible de les ajouter en base64 dans le CSS
        </section>

        <section>
          Limiter le nombre de requetes. 
          Une ou deux pour CSS et JS (une si petit, sinon deux en primordial et secondaire)
        </section>

      </section>


      <section>
        <section>
          <h1>Client</h1>
        </section>

        <section>
          HTML
          Pas grand chose à dire ici.
          Limiter le nombre de balises, aide aussi à la maintenabilité
          Code guide mdo
        </section>

        <section>
          Parsing du CSS
          Depuis la droite jusque la gauche, sélecteurs plus couteux que d'autres.
          Contre-intuitif, de dire que si super précis à gauche, alors selecteur optimisé. Inverse.
          Eviter le selecteur universel *, et les regexp dans les selecteurs d'attributs.
        </section>

        <section>
          Start Render Explication reflow/repaint.
          D'où, mettre CSS en haut pour lui économiser les reflows.
          Micro optim de mettre le contenu important déjà chargé en inline cf. 
          Guardian
        </section>
          
          
        <section>
          First execution
          Téléchragment de JS bloquant.
          A donc mettre en bas de page pour limiter, ou utiliser du async/defer (vérifier le fonctionnement). 
          Javasript bloquant car document.write peut changer le dom.
          Attention aux scripts de publicité (js-manners) 
        </section>
          
        <section>
          Asynchrone. 
          Prioriser ce qui doit se charger. 
          Tout ça n'est qu'au premier chargement, avant même que le user n'ai pu faire quoique ce soit. 
          Important donc de prioriser ce qui doit se charger en premier. 
          Boutons de sharing arrivent après contenu, idem pour la publicité et le tracking des visites. 
          Pas toujours facile à négocier avec le service marketing/etc. 
        </section>
          
          
        <section>
          Animation/transitions
          Grande majorité des effets d'animations sont faisable en simple CSS, sans passer par du js. 
          Tant que le JS s'execute, rien d'autre ne se passe. 
          Apparté sur la manière dont les boucles d'animations fonctionnent en JS 
          Une méthode qui se charge aussi souvent que possible (setTimeout) et qui calcule la 
          durée depuis la dernière fois et sait où elle se trouve dans l'animation, donc modifie les propriétés en fonctions. 
          Si modifie taille => reflow, sinon repaint. Comme repasse la main au browser, plein de repaint. 
          Plus performant de faire ces animations en CSS directement, car pluggué tout de suite sur GPU 
        </section>

        <section>
          CPU/GPU
          + Revoir la présentation de Paul Rouget à la TakeOff sur qui fait quoi, et comment en profiter?
        </section>

        <section>
          Usual Suspect #1
          Evenements qui fire trop régulièrement.
          Sur mousemove, scroll, etc.
        </section>

        <section>
          Usual Suspect #2
          Fuite mémoire avec des éléments supprimés du DOM qui ont toujours un
          event bindé, et donc pas supprimé
          Généralement moins couteux de mettre un seul événement sur un événement parent
          et profiter du bubbling.
        </section>

        <section>
          Usual suspect #3
          Ajouter plein d'éléments dans le DOM à le suite, force des reflow
          Les faire en batch
          Exemple d'une boucle qui ajoute plein d'éléments
        </section>


      </section>


      <section>
        <section>
          <h1>Humain</h1>
        </section>

        <section>
          http://calendar.perfplanet.com/2012/why-bother-with-performance-metrics-when-you-can-cheat/
          Mozilla make the throbber faster
          Tricher sur le easing, slow, puis de plus en plus fast
          Avoir des bandes qui bougent dans le sens inverse, augmente perception de vitesse
        </section>

        <section>
          Les utilsiateurs ne se disent pas "oh, ce site est lent, c'est dommage", mais "cette marque est pas très performante".
          Même site, même ergo, testée en ajoutant simplement un délai de 500ms est passé de "simple, facile à utiliser", à "lent, basique, dur à utiliser".
          http://calendar.perfplanet.com/2013/slow-pages-damage-perception/
        </section>


        <section>
          Finalement on optimise le chargement de nso pages pour que l'utilisateur final
          voit un site qui se charge vite. En plus d'influer sur la technique, on peut aussi influer sur
          le cerveau
        </section>

        <section>
          Placeholder
          Il est mieux de commencer à afficher quelque chose (même un bandeau de couleur)
          pour le header, ou des éléments non-utilisables plutot qu'un spinner qui tourne indéfiniment
        </section>

        <section>
          Spinner infini
          Rien de plus frustrant qu'une barre de progression qui n'évolue pas, ou qui continue plusieurs fois
          Eviter les spinner qui donnent une sensation de complétude si on ne peut pas la garantir
        </section>

        <section>
          L'oeil humain ne percoit rien en dessous de 100ms. Si une action prends moins de 300ms, elle
          est percu comme instanée. Inutile donc de mettre un spinner pour moins de 300ms.
          Au contraire, ca va lui donner la sensation que les choses sont lentes.
        </section>

        <section>
          Il peut arriver que les choses plantent, ou prennent plus de temps que prévu.
          Dans ce cas, il ne faut pas que l'utilisateur soit obligé de quitter la page.
          Il doit toujours pouvoir naviguer et aller autre part.
          Pas de backdrop qui prends tout et qui empeche de naviguer
        </section>

        <section>
          Enfin, comme disent les Animaniacs "If at first you don't suceed, blame it on your parents".
          Si c'est lent, essayer de faire en sorte que ce ne soit pas vous qu'on accuse.
          Facebook a fait le test sur son appli mobile, s'ils utilisent le spinner facebook, on pense que leur 
          appli est lente, s'ils utilisent le spinner iOs, on pense que l'iPhone est lent.
        </section>

      </section>

      <section>
        <h1>Questions ?</h1>
      </section>



    </div>

  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.min.js"></script>

  <script>
    // Full list of configuration options available here:
     // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: false,
      progress: true,
      history: true,
      center: true,

      theme: 'default',
      transition: 'linear',

      // Optional libraries used to extend on reveal.js
      dependencies: [{
        src: 'lib/js/classList.js',
        condition: function() {
          return !document.body.classList;
        }
      }, {
        src: 'plugin/highlight/highlight.js',
        async: true,
        callback: function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src: 'plugin/notes/notes.js',
        async: true,
        condition: function() {
          return !!document.body.classList;
        }
      }]
    });
  </script>

</body>

</html>
